#!/usr/bin/env python
# encoding: utf-8
"""
views.py

Created by Maximillian Dornseif on 2009-11-15.
Copyright (c) 2009 HUDORA. All rights reserved.
"""


from django import http
from django import shortcuts
from django.conf import settings
from taskmaster import forms
from taskmaster import models
from taskmaster import parser
from taskmaster import twitter
from xml.etree import ElementTree as ET
import datetime
import googleappsauth.views
import tweepy
import unittest


def user_login_required(f):
    """Log the user in."""
    def wrap(request, *args, **kwargs):
        # schon einen geauth'd User in der aktuellen Session?
        if not request.user.is_authenticated():
            # nein, wir haben noch keinen User. Also den Login ueber
            # Google Apps OpenID/OAuth starten und Parameter in Session speichern
            path = request.META['PATH_INFO']
            return googleappsauth.views.login(request,
                redirect_url="%s?%s" % (path, request.META.get('QUERY_STRING', '')))
        return f(request, *args, **kwargs)
    wrap.__doc__=f.__doc__
    wrap.__name__=f.__name__
    return wrap


def account_login_required(f):
    """Log the user in and Ensure that an Account object exists."""
    def wrap(request, *args, **kwargs):
        if not request.user.is_authenticated():
            # TODO: how to share code with user_login_required()?
            path = request.META['PATH_INFO']
            return googleappsauth.views.login(request,
                redirect_url="%s?%s" % (path, request.META.get('QUERY_STRING', '')))
        try:
            request.account = models.Account.objects.get(email=request.user.email)
        except models.Account.DoesNotExist:
            return http.HttpResponseRedirect('/account')
        return f(request, *args, **kwargs)
    wrap.__doc__=f.__doc__
    wrap.__name__=f.__name__
    return wrap


@account_login_required
def main_tasklist(request):
    ops = request.account.ops.exclude(state='deleted').exclude(state='finished')
    # TODO: move parsing / peep creation somewhere else
    for op in ops:
        parsed = parser.parse(op.task)
        if 'peep' in parsed:
            peep, created = request.account.peeps.get_or_create(name=parsed['peep'])
            if not op.peep:
                op.peep = peep
                op.save()
    return shortcuts.render_to_response('taskmaster/main.html', {'tasks': ops})


@account_login_required
def opml_tasklist(request):
    generated_on = str(datetime.datetime.now())
    # Configure one attribute with set()
    root = ET.Element('opml')
    root.set('version', '1.0')
    comment = ET.Comment('Generated by Sheila')
    root.append(comment)
    head = ET.SubElement(root, 'head')
    ET.SubElement(head, 'title').text = u"%s's Ops @ asksheila.org" % account.public_name
    ET.SubElement(head, 'dateCreated').text = generated_on
    ET.SubElement(head, 'dateModified').text = generated_on
    body = ET.SubElement(root, 'body')
    ops = request.account.ops.exclude(state='deleted').exclude(state='finished')
    for op in ops:
        ET.SubElement(body, 'outline', {'text':op.task})
    response_top = '<?xml version="1.0" encoding="utf-8"?>\n'
    response = http.HttpResponse(response_top + ET.tostring(root, 'utf-8'),
                             content_type='text/x-opml; charset=utf-8')
    response['Content-Disposition'] = 'attachment; asksheila.opml'
    return response


@account_login_required
def op_detail(request, designator):
    op = request.account.ops.get(designator=designator)
    return shortcuts.render_to_response('taskmaster/op_detail.html', {'op': op})


@account_login_required
def peep_list(request):
    peeps = request.account.peeps.all()
    return shortcuts.render_to_response('taskmaster/peep_list.html', {'peeps': peeps})


@account_login_required
def peep_detail(request, designator):
    peep = request.account.peeps.get(designator=designator)
    return shortcuts.render_to_response('taskmaster/peep_detail.html', {'peep': peep})


@user_login_required
def account_settings(request):
    try:
        instance = models.Account.objects.get(email=request.user.email)
    except models.Account.DoesNotExist:
        # create new account / empty form
        instance = None
        twitter_problem = False
    if request.method == 'POST':
        form = forms.AccountForm(request.POST, instance=instance)
        if form.is_valid():
            account = form.save()
            return http.HttpResponseRedirect('')
    else:
        if not instance:
            name = ' '.join([request.user.first_name, request.user.last_name]).strip()
            data = {'email': request.user.email, 'public_name': name, 'private_name': name}
            form = forms.AccountForm(data)
        else:
            if instance.twitter_user:
                twitter_problem = not twitter.connetion_ok(instance)
            form = forms.AccountForm(instance=instance)
    return shortcuts.render_to_response('taskmaster/account.html',
                                        {'form':form, 'twitter_problem': twitter_problem,
                                         'account': instance})


def maintenance_pull_tweets(request):
    twitter.handle_direct_messages()
    return http.HttpResponse('ok')


@user_login_required
def api_add_task(request):
    opid = request.GET.get('taskid')
    try:
        account = models.Account.objects.get(email=request.user.email)
    except models.Account.DoesNotExist:
        return http.HttpResponseForbidden()
    person = request.GET.get('person')
    description = request.GET.get('task')
    # source = request.user.email
    op = models.Op.objects.create(account=account, task=description)
    return http.HttpResponse(op.designator)


@user_login_required
def api_delete_task(request):
    opid = request.GET.get('taskid')
    try:
        account = models.Account.objects.get(email=request.user.email)
    except models.Account.DoesNotExist:
        return http.HttpResponseForbidden()
    op = account.ops.get(designator=opid)
    op.state = 'deleted'
    op.save()
    return http.HttpResponse('ok')
